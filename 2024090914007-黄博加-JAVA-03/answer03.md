1. 整型byte short int long  字符型 char   浮点型 float double   布尔型 boolean
2. 2.byte占1个字节，表示范围是-128到127；short占2个字节，表示范围是-32768到32767；int占4个字节，表示范围是-2^31到(2^31)-1；long占8个字节，表示范围是-2^63到(2^63)-1
3. 自动类型转换，b的值是52。char变量与int变量相加时，char变量会自动转成它的编码，然后再与int变量相加。字符0转成了48。（查资料说java用unicode编码，是16进制的，但48是ASCII码表0里的十进制编码，遂感觉奇怪。又查到java同时也实现了ASCII，所以字符编码这部分暂时还不懂）
4. 1. 第一块代码提示过时了，查资料看到是构造方法过时，似乎使用低版本java才能运行，不过据我对new关键字的了解，猜测输出结果应该是   false，因为两者是不同的对象，地址是不同的，因此会输出false。
   1. 第二块代码输出true。查阅文档得知,Integer.valueOf()方法会返回一个对应输入值的Integer实例，而且这个方法会缓存-128到127范围的数字。由String的复用机制猜测，是因为k在赋值时，发现18是之前缓存过的数字，所以就复用了之前z的同一个Integer实例。这样的话z和k地址值相同，也就输出true了。（但我不了解缓存的机制是什么）
   2. 第三块代码输出false。300超出缓存范围，p在赋值时不会复用m对应的Integer实例，所以地址值不同，输出false。
5. 1. 运行结果 第一行13 第二行6 8
   2. 在c的计算过程中，a先自增变为6，然后参与计算，b作为7参与计算，得出结果13赋值给c，最后b自增变为8，第一行输出c的值13。而第二行由于有字符串参与计算，所以数字会先被转为字符串，再与空格进行拼接，最后输出的也是字符串，也就是"6 8"。
   3. 又查阅资料得知，具体过程是遇到字符串之后才会开始转字符串拼接。如果代码写的是a+b+" "，那么结果就会是"14 "。

6.    一个数的相反数的补码与这个数的原码相加等于0。反码能部分地解决正负数相加的问题，但在从负向正跨0的时候会出问题。比如8+(-5) 0000 1000 + 1111 1010(反) = 0000 0010 = 3，结果没问题。3+(-4) 0000 0011 + 1111 1011(反) = 1111 1110(反)->1000 0001 = -1，结果也没问题。**但是**4+(-3) 0000 0100 + 1111 1100(反) = 0000 0000 = 0，这就错误了。因为过程中经过两个"0"，就是1111 1111和0000 0000。所以把负数的反码+1得到补码，4-3就会得到0000 0001即1了。此时1111 1111是-1，0000 0000才是0。
   1. a=0000 0010，那么-a=1000 0010(原)->1111 1101(反)->1111 1110(补)。然后a&(-a)= 0000 0010。
   2. 设b=0001 0010，-b=1110 1110(补)，b&(-b)=0000 0010。再设c=0010 1001，-c=1101 0111，c&(-c)=0000 0001。可以看出来结果应该是原数从右往左数第一个1带上它右边的0